/*
 * This file is part of COMP332 Assignment 3 2019.
 *
 * Lintilla, a simple functional programming language.
 *
 * Â© 2019, Dominic Verity and Anthony Sloane, Macquarie University.
 *         All rights reserved.
 *
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 *
 * Lintilla to SEC machine code translator.
 */

package lintilla

/**
  * Translator from Lintilla source programs to SEC target programs.
  */
object Translator {

  var control_var: String = ""
  var step_value: Int = 0

  import SECDTree._
  import LintillaTree._
  import scala.collection.mutable.ListBuffer

  import scala.language.implicitConversions

  implicit private def vecToList[T](vec : Vector[T]) = vec.toList

  /**
    * Return a frame that represents the SEC instructions for a Lintilla
    * program.
    */
  def translate (program : Program) : Frame =
    program match {
      case Program(exps) => translateToFrame(exps)
    }

  /**
    * Translate a sequence of Lintilla expressions and return a frame containing
    * the generated SEC code.
    */
  def translateToFrame(exps : List[Expression]) : Frame = {

    // An instruction buffer for accumulating the translated SEC code.
    val instrBuffer = new ListBuffer[Instr] ()

    // Generate an instruction by appending it to the instruction buffer.
    def gen (instr : Instr) {
      instrBuffer.append (instr)
    }

    /**
      * Translate a sequence of expressions in order, adding the SEC code
      * generated by each one to the end of the instruction buffer.
      *
      * If the first expression in the given sequence is a `let` or `fn`
      * declaration then rest of the sequence is translated into a frame, by
      * calling `translateClosureBody`. This is then used to construct an
      * `IClosure` instruction whose purpose is to bind the declared identifier
      * in the environment used when executing that frame.
      */
    def translateSeq(list : List[Expression]) {
      list match {
        case (LetDecl(IdnDef(i), exp) :: rest) =>
          translateExp(exp)
          gen(IClosure(None, List(i), translateToFrame(rest)))
          gen(ICall())
        case (FnDecl(IdnDef(n), args, _, Block(body)) :: rest) =>
          gen(IClosure(Some(n),
                       args.map({case ParamDecl(IdnDef(i), _) => i}),
                       translateToFrame(body)))
          gen(IClosure(None, List(n), translateToFrame(rest)))
          gen(ICall())
        case (exp :: rest) =>
          translateExp(exp)
          translateSeq(rest)
        case _ => ()
      }
    }

    /**
      * Translate a single Lintilla expression, adding the generated SEC code to
      * the end of the current instruction buffer.
      */
    def translateExp(exp : Expression) {
      exp match {

        // To translate a Block simply translate the list of expressions it contains

        case Block(exps) => translateSeq(exps)

        // To translate a 'print' simply translate its parameter and add a
        // print instruction.

        case PrintExp(e) =>
          translateExp(e)
          gen(IPrint())

        // To translate a function application first translate its arguments
        // then translate the funtion expression itself.

        case AppExp(fn, args) =>
          args.foreach(translateExp)
          translateExp(fn)
          gen(ICall())

        // Translate relational operators

        case EqualExp(l, r) =>
          translateExp(l)
          translateExp(r)
          gen(IEqual())

        case LessExp(l, r) =>
          translateExp(l)
          translateExp(r)
          gen(ILess())

        // Translate arithmetic operators

        case PlusExp(l, r) =>
          translateExp(l)
          translateExp(r)
          gen(IAdd())

        case MinusExp(l, r) =>
          translateExp(l)
          translateExp(r)
          gen(ISub())

        case StarExp(l, r) =>
          translateExp(l)
          translateExp(r)
          gen(IMul())

        case SlashExp(l, r) =>
          translateExp(l)
          translateExp(r)
          gen(IDiv())

        case NegExp(e) =>
          gen(IInt(0))
          translateExp(e)
          gen(ISub())

        // Translate constant expressions

        case BoolExp(b) =>
          gen(IBool(b))

        case IntExp(i) =>
          gen(IInt(i))

        // Translate an identifier use

        case IdnExp(IdnUse(n)) =>
          gen(IVar(n))

        // Translate an 'if' expression

        case IfExp(c, Block(t), Block(e)) =>
          translateExp(c)
          gen(
            IBranch(
              translateToFrame(t),
              translateToFrame(e)
            )
          )

        // Translate an 'AND' operator
        case AndExp(l, r) =>
          translateExp(l) // Put left side of AND to top of stack
          gen( // Generate instruction
            IBranch( // Evaluate the truth value of the expression on top of the stack.
              translateToFrame(List(r)), // LHS Expression = True: Then the AND operation truth value is up to the right hand side.
              List(IBool(false)) // LHS Expression = False: Then the AND operation truth value is automatically false without the need to inspect the RHS
            )
          )

        // Translate an 'OR' operator
        case OrExp(l, r) =>
          translateExp(l) // Put left side of OR to top of stack
          gen( // Generate instruction
            IBranch( // Evaluate the truth value of the expression on top of the stack.
              List(IBool(true)), // LHS Expression = True: Then the OR operation truth value is automatically true without the need to inspect RHS.
              translateToFrame(List(r)) // LHS Expression = False: Then the OR operation truth value is up to the right side.
            )
          )

        // Translate a 'NOT' operator
        case NotExp(e) =>
          translateExp(e) // Put expression on top of stack
          gen( // Generate instruction
            IBranch( // Evaluate the truth value of the expression on top of the stack.
              List(IBool(false)), // Expression = True: Flip value to false.
              List(IBool(true)) // Expression = False: Flip value to true.
            )
          )

        // Translate array creation
        case ArrayExp(tipe) =>
          gen(IArray()) //Simply generate an array

        // Translate array length
        case LengthExp(array) =>
          translateExp(array) // Push array onto stack
          gen(ILength()) // Generate the length of the array at the top of the stack

        // Translate array deference
        case DerefExp(array, index) =>
          translateExp(array) // Push array
          translateExp(index) // Push index
          gen(IDeref()) // Generate the item at the index of the array onto the stack

        // Translate array assignment
        case AssignExp(DerefExp(v, i), e) =>
          translateExp(v) // Push array
          translateExp(i) // Push index
          translateExp(e) // Push element desired to be put into array
          gen(IUpdate())  // Generate an update to the array

        // Translate array extension
        case AppendExp(array, exp) =>
          translateExp(array) // Push Array
          translateExp(exp)   // Push Exp
          gen(IAppend())      // Generate an append

        case ForExp(IdnDef(id), from, to, step, body) =>
          // Save for later
          val old_control_var = control_var
          val old_step_value = step_value
          // Get new vars
          control_var = id
          step match {
              // If theres a value then get it
            case Some(i) => step_value = i.asInstanceOf[Integer]
              // Otherwise step = 1
            case None => step_value = 1
          }
          // translate from and to onto stack
          translateExp(from)
          translateExp(to)
          gen(
          IClosure(
            None,
            List("_from", "_to", "_break_cont"),
            List(
              IClosure(
                None,
                List("_loop_cont"),
                List(
                  IVar("_from"),
                  IVar("_loo_count")
                )
              ),
              ICallCC(),
              IClosure(
                None,
                List(control_var, "_loop_cont"),
                // Combine all instructions
                // Here must determine if step_value is greater than or less than 0. Use IBranch
                List(
                  IInt(0),
                  IInt(step_value),
                  ILess(),
                  IBranch(
                    List(
                      IVar(control_var),
                      IVar("_to"),
                      ILess()
                    ),
                    List(IVar("_to"),
                      IVar(control_var),
                      ILess())
                  )
                )
                  ++
                  List(
                  IBranch(
                    List(
                      IVar("_break_cont"),
                      IResume()
                    ),
                    List()
                  )
                  )
                  ++
                  // Translate the body of the for loop
                  translateToFrame(body.stmts)
                  ++
                  List(IVar(control_var),
                  IInt(step_value),
                  IAdd(),
                  IVar("_loop_cont"),
                  IVar("_loop_cont"),
                  IResume()
                )
              ),
              ICall()
            )
          )
          )
          ICallCC()
          // Change back vars
          control_var = old_control_var
          step_value = old_step_value


          // Loop expression
        case LoopExp() =>
          IDropAll()
          IVar(control_var)
          IInt(step_value)
          IAdd()
          IVar("_loop_cont")
          IVar("_loop_cont")
          IResume()

          // Break expression
        case BreakExp() =>
          IDropAll()
          IVar("_break_cont")
          IResume()


        // Other cases have already been handled elsewhere

        case _ => ()

      }

    }

    // Call sequence translator
    translateSeq(exps)

    // Return generated code frame.
    instrBuffer.toList
  }

  /**
    * Evaluate an integer constant expression.
    */ 
  def evalIntConst(e : Expression): Int =
    e match {
      case IntExp(v) => v
      case NegExp(n) => -evalIntConst(n)
      case PlusExp(l, r) => evalIntConst(l) + evalIntConst(r)
      case MinusExp(l, r) => evalIntConst(l) - evalIntConst(r)
      case StarExp(l, r) => evalIntConst(l) * evalIntConst(r)
      case SlashExp(l, r) => evalIntConst(l) / evalIntConst(r)
      case _ => 0
    }

}
